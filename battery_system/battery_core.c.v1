#include <linux/kernel.h>
#include <linux/module.h>
#include <linux/platform_device.h>
#include <linux/slab.h>
#include <linux/mutex.h>
#include <linux/string.h>
#include <linux/power_supply.h>
#include <linux/mfd/88pm860x.h>
#include <linux/delay.h>
#include <linux/rtc.h>
#include <linux/of.h>
#include <linux/mod_devicetable.h>
#include <linux/qpnp/qpnp-adc.h>
#include <linux/workqueue.h>
#include "battery_core.h"


#define pr_fmt(fmt) "%s: " fmt, __func__

//*****************************************************
//*  Таблица соответствия напряжения и уровня заряда
//*****************************************************

struct capacity {
  int percent;
  int vmin;
  int vmax;
  int offset;
  int hysteresis;
};
  
// 
struct capacity battery_capacity_table[12]= {
//  %       vmin     vmax   offset hysteresis
   {0,      3100,    3597,    0,    10},
   {1,      3598,    3672,    0,    10},
   {10,     3673,    3735,    0,    10},
   {20,     3736,    3757,    0,    10},
   {30,     3758,    3788,    0,    10},
   {40,     3789,    3832,    0,    10},
   {50,     3833,    3909,    0,    10},
   {60,     3910,    3988,    0,    10},
   {70,     3989,    4072,    0,    10},
   {80,     4073,    4156,    0,    10},
   {90,     4157,    4200,    0,    10},
   {100,    4201,    4500,    0,    10}
};   
#define battery_capacity_table_size 12




//*****************************************************
//*  Таблица перевода напряжения в температуру
//*****************************************************
struct ntc_tvm {
   int tntc;
   int tnvc;
}

struct ntc_tvm ntc_tvm_tables[] = {
// температура  напряжение
     {-45,      1800000},         
     {-40,      1693138},
     {-35,      1665952},
     {-30,      1633668},
     {-25,      1595877},
     {-20,      1551873},
     {-15,      1501569},
     {-10,      1444173},
     {-5,       1379919},
     {0,        1308687},
     {5,        1231323},
     {10,       1149570},
     {15,       1065303},
     {20,       979678},
     {25,       895000},
     {30,       812338},
     {35,       733267},
     {40,       658735},
     {45,       589543},
     {50,       525875},
     {55,       467795},
     {60,       415297},
     {65,       368123},
     {70,       326146},
     {75,       288699},
     {80,       255758},
     {85,       226817},
     {90,       201430},
     {95,       179128},
     {100,      159466},
     {105,      142204},
     {110,      127049},
     {115,      113656},
     {120,      101957},
     {125,      91546}
};    

#define ntc_table_size 35

// 592 байта
struct battery_core {
   struct battery_interface* api;   // 0
   charger_core_interface * charger; // 4
   struct device* dev;  // 8
   int x10;
   struct mutex lock; //12, 40 байт
   int x52;
   struct wakeup_source ws;  // 56, размер 152   
   struct power_supply psy;  // 208, размер 148

   workqueue_struct * mon_queue; // 316

 //---------------------------------  
   struct delayed_work work;     // 320, размер  76:  320-386
   // work_strict work
   //             atomic_long_t data;      320
   //             struct list_head entry;  324-328

   //void (*battery_core_monitor_work)(work_struct *); //332
   struct timer_list timer; //336, размер 52: 336-392

   // void (*function)(unsigned int); //352
//-----------------------------------
//   struct delayed_work* pwork; // 356
   
   int x392;
   int x396;
   int x400;
   int x404;
   int x408;
   char* bname;  //412
   int x416;
   int x420;
   int x424;
   int x428;
   int x432;
   int x436;
   int x440;
   int x444;
   int x448;
   int x452;
   int x456;
   int x460;
   int x464;
   int x468;
   int x472;
   int x476;
   int x480;
   int x484;
   int x488;
   int x492;
   
   int x536;
   int x540;
   struct ntc_tvm* ntc;  // 544
   int ntcsize;
   struct capacity* cap; //552
   int capsize;
   
}   

//*****************************************************
//*  Таблица параметров батарейки
//*****************************************************
static enum power_supply_property battery_core_power_props = {
  POWER_SUPPLY_PROP_STATUS, 
  POWER_SUPPLY_PROP_PRESENT, 
  POWER_SUPPLY_PROP_TEMP, 
  POWER_SUPPLY_PROP_HEALTH, 
  POWER_SUPPLY_PROP_VOLTAGE_NOW, 
  POWER_SUPPLY_PROP_VOLTAGE_AVG
  POWER_SUPPLY_PROP_CAPACITY, 
  POWER_SUPPLY_PROP_VOLTAGE_MAX, 
  POWER_SUPPLY_PROP_CURRENT_MAX, 
  POWER_SUPPLY_PROP_CURRENT_NOW
};  

//*****************************************************
//*  Проверка доступности записи уазанного параметра
//*****************************************************
battery_core_property_is_writeable(power_supply *psy, power_supply_property psp) {
  
if ((psp ==  POWER_SUPPLY_PROP_PRESENT) || 
    (psp == POWER_SUPPLY_PROP_VOLTAGE_NOW) || 
    (psp == POWER_SUPPLY_PROP_TEMP))
    return 1;
return 0;
}

//*****************************************************
//* Чтение параметра батареи
//*****************************************************
int battery_core_get_property(power_supply *psy, power_supply_property psp, power_supply_propval *val) {
  

switch(psp){
  case POWER_SUPPLY_PROP_HEALTH:
    *val=
  

//*****************************************************
//*  Регистрация в системе батарейного дарйвера
//*****************************************************
int battery_core_register(struct device* dev, struct battery_interface* api) {
  
struct battery_core* bat;  
struct workqueue_struct* swq;
int rc;

if ((dev==0) || (api==0)) return -EINVAL;
if (api->bname == 0) return -EINVAL;
if (api->bname[0] == 0) return -EINVAL;


bat=kmalloc(sizeof(battery_core),__GFP_ZERO|GFP_KERNEL);
if (bat == 0) {
  pr_err("cannot get enough memory!\n");
  return -ENOMEM;
}

bat->dev=dev;
mutex_init(&bat->lock);
wakeup_source_prepare(&bat->ws, api->bname);
wakeup_source_add(&bat->ws);
bat->x416=2;
bat->x436=4350000;
bat->bname=api->bname;
bat->x424=1000000;
bat->x420=0;
bat->x444=0;
bat->x428=0;
bat->x432=0;
bat->x440=80;
bat->x448=3;
bat->x456=25;
bat->x476=10;
bat->x452=0;
bat->x460=0;
bat->x536=1800000;
bat->x540=1800000;
bat->x464=0;
bat->x468=0;

bat->ntc=ntc_tvm_tables;
bat->ntcsize=35;
bat->cap=battery_capacity_table;
bat->x556=battery_capacity_table_size;

bat->x480=3000;
bat->x472=0;
bat->x488=3064;
bat->x568=0;
bat->x484=3264;
bat->x572=0;
bat->x576=0;
bat->x580=0;
bat->x584=0;
bat->x588=0;
bat->x492=3600;
bat->x532=2;
bat->x496=4450;
bat->x500=4200;
bat->x504=4350;
bat->x508=-20;
bat->x512=-5;
bat->x516=-3;
bat->x520=53;
bat->x524=55;
bat->x528=65;

// кросс-ссылки структур друг на друга
bat->api=api;
api->bat=bat;

bat->charger=charger_core_get_charger_interface_by_name(api->bname);
api->x_timer_suspend_proc=0;
api->alarm_wakeup_proc=battery_core_wakeup;
api->timer_resume_proc=0;
api->timer_suspend_proc=0;

bat->x396=20000;
bat->x400=25000;
bat->x320=-32;

bat->work.work.next=&bat->work.work.next;
bat->work.work.prev=&bat->work.work.next;

bat->x404=0;
bat->x408=0;
bat->work.func=battery_core_monitor_work;

init_timer_key(&bat->timer,2,0,0);

bat->timer.data=(unsigned int)(&bat->work);


bat->timer.function=delayed_work_timer_fn;
bat->mon_queue = alloc_workqueue("batt_monitor_wq", WQ_MEM_RECLAIM, 1);
swq=bat->mon_queue;
if (bat->mon_queue == 0) {
  pr_err("failed to create_workqueue batt_monitor_wq!");
  swq=*system_wq;
}
queue_delayed_work_on(1,swq,&bat->work ,msecs_to_jiffies(250);

bat->psy.name=bat->bname;
bat->psy.type=1;
bat->psy.properties=battery_core_power_props;
bat->psy.num_properties=10;
bat->psy.get_property=battery_core_get_property;
bat->psy.set_property=battery_core_set_property;
bat->psy.property_is_writeable=battery_core_property_is_writeable;
bat->psy.external_power_changed=battery_core_external_power_changed;

rc=power_supply_register(bat->dev,&bat->psy);
if (rc<0) {
  pr_err("failed to register psy_%s\n",bat->psy.name);
  goto err_power_supply_register_bat;
}

rc=battery_core_add_sysfs_interface(bat->psy.dev)
if (rc < 0) {
  pr_err("failed to add sysfs interface!\n");
  power_supply_unregister(&bat->psy);
  goto err_power_supply_register_bat;
}

battery_core_external_power_changed(&bat->psy);
pr_err("Battery Core Version %s(Built at %s %s)!","4.1.5f",__DATE__,__TIME__);
return 0;

// Обработка ошибок
err_power_supply_register_bat:

cancel_delayed_work_sync(&bat->work);
if (bat->mon_queue != 0) destroy_workqueue(bat->mon_queue);
wakeup_source_remove(&bat->ws);
wakeup_source_drop(&bat->ws);
mutex_destroy(&bat->lock);
kfree(bat);
return rc;
}

//*****************************************************
//*  Отключение батарейного дарйвера
//*****************************************************
void battery_core_unregister(device *dev, battery_interface *api) {
  
if ((api== 0) || (api->bat == 0)) return;
battery_core_remove_sysfs_interface(dev);
power_supply_unregister(&bat->psy);
if (bat->mon_queue != 0) destroy_workqueue(bat->mon_queue);
wakeup_source_remove(&bat->ws);
wakeup_source_drop(&bat->ws);
mutex_destroy(&bat->mutex);
kfree(bat);
}



		      
		      